package workcraft.gate;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.LinkedList;
import java.util.UUID;

import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.filechooser.FileFilter;

import workcraft.ModelValidationException;
import workcraft.Tool;
import workcraft.ToolType;
import workcraft.WorkCraftServer;
import workcraft.editor.Editor;

public class GatesBlifSaver implements Tool {
	public static final String _modeluuid = "6f704a28-e691-11db-8314-0800200c9a66";
	public static final String _displayname = "Berkeley Logic Interchange Format (BLIF)";
	
	public void deinit(WorkCraftServer server) {
		// TODO Auto-generated method stub
	}

	public ToolType getToolType() {
		return ToolType.EXPORT;
	}

	public void init(WorkCraftServer server) {
		// TODO Auto-generated method stub
	}

	public boolean isModelSupported(UUID modelUuid) {
		// TODO Auto-generated method stub
		return false;
	}

	private Boolean zeroRequired;
	private String zeroName;
	
	private boolean isGateSet(BasicGate g) {
		return (g.out.getFirst().getState()==GateContact.StateType.set);
	}
	
	private String getInputName(GateContact con) {
		if(con.srcContact==null) {
			zeroRequired = true;
			return zeroName;
		}
		else
			return con.srcContact.getParentGate().getId();
	}
	
	private void printGateCap(PrintWriter out, BasicGate g, boolean addSelfInput) {
		String latchOutName = "";
		for(GateContact con : g.getInputContacts())
			if(con.srcContact!=null && con.srcContact.getParentGate()==g || addSelfInput) {
				// self connected
				latchOutName = g.getId()+"_L";
				out.println(".latch "+g.getId()+" "+latchOutName+" "+(isGateSet(g)?"1":"0"));
				break;
			}
		
		out.print(".names");
		for(GateContact con : g.getInputContacts()) {
			if(con.srcContact==null) {
				zeroRequired = true;
				out.print(" "+zeroName);
			}
			else if(con.srcContact.getParentGate()==g)
				out.print(" "+latchOutName);
			else
				out.print(" "+con.srcContact.getParentGate().getId());
		}
		if(addSelfInput)
			out.print(" "+latchOutName);
		out.println(" "+g.getId()+" # "+g.getClass().getName());
	}
	
	private Boolean isGateInverted(BasicGate g) {
		return g.getOutputContacts().get(0).getInvertSignal();
	}
	
	private void printInput(PrintWriter out, GateContact con, Boolean inv) {
		out.print((con.getInvertSignal()^inv)?"0":"1");
	}
	
	public void writeFile (String path, GateModel doc) throws IOException {
		try {
			doc.prepareMap();
		}
		catch (ModelValidationException err) {
			System.err.println("Unable to convert format: "+err.getMessage());
			return;
		}
		LinkedList<Input> inputs = new LinkedList<Input>();
		LinkedList<Output> outputs = new LinkedList<Output>();
		zeroName = "GND";
		for(BasicGate g : doc.gates) {
			if(g.getId()==zeroName)
				zeroName = "_"+zeroName;
			if(g instanceof Input)
				inputs.add((Input)g);
			else if(g instanceof Output)
				outputs.add((Output)g);
		}
		PrintWriter out = new PrintWriter(new FileWriter(path));
		out.println("# File generated by Workcraft.");
		out.print(".inputs");
		for(Input g : inputs) out.print(" "+g.getId());
		out.println();
		out.print(".outputs");
		for(Output g : outputs) out.print(" "+g.getId());
		out.println();
		
		zeroRequired = false;
		for(BasicGate g : doc.gates) {
			
			if(g instanceof Joint || g instanceof Input) {
				// skip
			}
			
			else if(g instanceof Output) {
				printGateCap(out, g, false);
				out.println("1 1");
			}
			
			else if(g instanceof NotGate) {
				printGateCap(out, g, false);
				printInput(out, g.getInputContacts().get(0), false);
				out.println(isGateInverted(g)?" 0":" 1");
			}
			
			else if(g instanceof AndGate) {
				printGateCap(out, g, false);
				for(GateContact con : g.getInputContacts())
					printInput(out, con, false);
				out.println(isGateInverted(g)?" 0":" 1");
			}
			
			else if(g instanceof OrGate) {
				printGateCap(out, g, false);
				if(isGateInverted(g)) {
					for(GateContact con : g.getInputContacts())
						printInput(out, con, true);
					out.println(" 1");
				}
				else {
					for(GateContact con2 : g.getInputContacts()) {
						for(GateContact con : g.getInputContacts())
							if(con==con2)
								printInput(out, con, false);
							else
								out.print("-");
						out.println(" 1");
					}
				}
			}
			
			else if(g instanceof XorGate) {
				if(g.getInputContacts().size()!=2) {
					System.err.println("N-ary XOR gates not supported");
					continue;
				}
				printGateCap(out, g, false);
				printInput(out, g.getInputContacts().get(0), false);
				printInput(out, g.getInputContacts().get(1), !isGateInverted(g));
				out.println(" 1");
				printInput(out, g.getInputContacts().get(0), true);
				printInput(out, g.getInputContacts().get(1), isGateInverted(g));
				out.println(" 1");
			}
			
			else if(g instanceof CElement) {
				if(g.getInputContacts().size()!=2) {
					System.err.println("N-ary C-elements not supported");
					continue;
				}
				out.print(".mlatch "+(isGateInverted(g)?"ncel":"c2"));
                out.print(" a="+getInputName(g.getInputContacts().get(0)));
                out.print(" b="+getInputName(g.getInputContacts().get(1)));
                out.println(" y="+g.getId());
			}

/*			else if(g instanceof CElement) {
				printGateCap(out, g, true);
				for(GateContact con2 : g.getInputContacts()) {
					for(GateContact con : g.getInputContacts())
						if(con!=con2)
							printInput(out, con, isGateInverted(g));
						else
							out.print("-");
					out.println(isGateInverted(g)?"0 1":"1 1");
				}
				for(GateContact con : g.getInputContacts())
					printInput(out, con, isGateInverted(g));
				out.println("- 1");
			}*/
			
			else if(g instanceof ComplexGate) {
				printGateCap(out, g, false);
				ComplexGate cg = (ComplexGate) g;
				if((cg.getComplexType()==1)^isGateInverted(g)) {
					// tricky loop
					Integer nsub = cg.getSubGatesNumber();
					Integer nclauses = 1;
					for(Integer i=0; i<nsub; i++)
						nclauses *= cg.getSubGateInputsNumber(i);
					for(Integer x=0; x<nclauses; x++) {
						Integer xn = x;
						for(Integer isub=0; isub<nsub; isub++) {
							Integer ninputs = cg.getSubGateInputsNumber(isub);
							for(Integer ii = 0; ii<ninputs; ii++)
								if(ii==xn%ninputs)
									printInput(out, cg.getSubGateInput(isub, ii), isGateInverted(g));
								else
									out.print("-");
							xn /= ninputs;
						}
						out.println(" 1");
					}
				}
				else {
					// simple loop
					Integer nsub = cg.getSubGatesNumber();
					for(Integer jsub = 0; jsub<nsub; jsub++) {
						for(Integer isub = 0; isub<nsub; isub++) {
							Integer ninputs = cg.getSubGateInputsNumber(isub);
							for(Integer ii = 0; ii<ninputs; ii++)
								if(isub==jsub)
									printInput(out, cg.getSubGateInput(isub, ii), isGateInverted(g));
								else
									out.print("-");
						}
						out.println(" 1");
					}
				}
			}
			
			else {
				System.err.println("Converter does not support class "+g.getClass().getName());
			}
		}
		if(zeroRequired) {
			out.println(".names "+zeroName);
		}
		
		// initials
		out.println(".end");
		out.print(".initial");
		for(BasicGate g : doc.gates) {
			if(g instanceof Joint || g instanceof Input)
				continue;
			if(g.out.size()>0)
				out.print(" "+(isGateSet(g)?"":"!")+g.getId());
		}

		out.println();
		out.println(".end");
		out.close();
	}
	
	class BlifFileFilter extends FileFilter {
		@Override
		public boolean accept(File f) {
			if (f.isDirectory())
				return true;
			if (f.getName().endsWith(".blif"))
				return true;
			return false;
		}

		@Override
		public String getDescription() {
			return "Berkeley Logic Interchange (*.blif)";
		}
	}
	
	public void run(Editor editor, WorkCraftServer server) {
		GateModel doc = (GateModel) (editor.getDocument());
		String last_directory = editor.getLastDirectory();

		JFileChooser fc = new JFileChooser();
		fc.setFileFilter(new BlifFileFilter());
		if (last_directory != null)
			fc.setCurrentDirectory(new File(last_directory));
		if (fc.showSaveDialog(null)==JFileChooser.APPROVE_OPTION)
		{
			String path = fc.getSelectedFile().getPath();
			if (!path.endsWith(".blif")) path += ".blif";
			{
				// saving in .g format
				try
				{
					writeFile(path, doc);
				}
				catch (IOException e)
				{
					JOptionPane.showMessageDialog(null, "File could not be opened for writing.");
					return;
				}					
			}
		}
	}

}
